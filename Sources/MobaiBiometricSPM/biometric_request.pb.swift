// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: node_modules/@mobaibio/biometric-request-proto/biometric_request.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Mobai_BiometricRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var recognitionRequest: Mobai_RecognitionRequest {
    get {return _recognitionRequest ?? Mobai_RecognitionRequest()}
    set {_recognitionRequest = newValue}
  }
  /// Returns true if `recognitionRequest` has been explicitly set.
  var hasRecognitionRequest: Bool {return self._recognitionRequest != nil}
  /// Clears the value of `recognitionRequest`. Subsequent reads from it will return its default value.
  mutating func clearRecognitionRequest() {self._recognitionRequest = nil}

  var padRequest: Mobai_PadRequest {
    get {return _padRequest ?? Mobai_PadRequest()}
    set {_padRequest = newValue}
  }
  /// Returns true if `padRequest` has been explicitly set.
  var hasPadRequest: Bool {return self._padRequest != nil}
  /// Clears the value of `padRequest`. Subsequent reads from it will return its default value.
  mutating func clearPadRequest() {self._padRequest = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _recognitionRequest: Mobai_RecognitionRequest? = nil
  fileprivate var _padRequest: Mobai_PadRequest? = nil
}

struct Mobai_RecognitionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var referenceImage: Data = Data()

  var referenceMetaData: Mobai_RecognitionMetaData {
    get {return _referenceMetaData ?? Mobai_RecognitionMetaData()}
    set {_referenceMetaData = newValue}
  }
  /// Returns true if `referenceMetaData` has been explicitly set.
  var hasReferenceMetaData: Bool {return self._referenceMetaData != nil}
  /// Clears the value of `referenceMetaData`. Subsequent reads from it will return its default value.
  mutating func clearReferenceMetaData() {self._referenceMetaData = nil}

  var probeImage: Data = Data()

  var probeMetaData: Mobai_RecognitionMetaData {
    get {return _probeMetaData ?? Mobai_RecognitionMetaData()}
    set {_probeMetaData = newValue}
  }
  /// Returns true if `probeMetaData` has been explicitly set.
  var hasProbeMetaData: Bool {return self._probeMetaData != nil}
  /// Clears the value of `probeMetaData`. Subsequent reads from it will return its default value.
  mutating func clearProbeMetaData() {self._probeMetaData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _referenceMetaData: Mobai_RecognitionMetaData? = nil
  fileprivate var _probeMetaData: Mobai_RecognitionMetaData? = nil
}

struct Mobai_RecognitionMetaData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var width: Int32 = 0

  var height: Int32 = 0

  var orientation: Mobai_RecognitionMetaData.ImageOrientation = .portrait

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ImageOrientation: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case portrait // = 0
    case landscapeRight // = 1
    case portraitUpsideDown // = 2
    case landscapeLeft // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .portrait
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .portrait
      case 1: self = .landscapeRight
      case 2: self = .portraitUpsideDown
      case 3: self = .landscapeLeft
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .portrait: return 0
      case .landscapeRight: return 1
      case .portraitUpsideDown: return 2
      case .landscapeLeft: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Mobai_RecognitionMetaData.ImageOrientation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mobai_RecognitionMetaData.ImageOrientation] = [
    .portrait,
    .landscapeRight,
    .portraitUpsideDown,
    .landscapeLeft,
  ]
}

#endif  // swift(>=4.2)

struct Mobai_PadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var padData: [Data] = []

  var padMetaData: Mobai_PadMetaData {
    get {return _padMetaData ?? Mobai_PadMetaData()}
    set {_padMetaData = newValue}
  }
  /// Returns true if `padMetaData` has been explicitly set.
  var hasPadMetaData: Bool {return self._padMetaData != nil}
  /// Clears the value of `padMetaData`. Subsequent reads from it will return its default value.
  mutating func clearPadMetaData() {self._padMetaData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _padMetaData: Mobai_PadMetaData? = nil
}

struct Mobai_PadMetaData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionID: String = String()

  var transactionType: Mobai_PadMetaData.TransactionType = .attack

  var itemNumber: Int32 = 0

  var attackLevel: Mobai_PadMetaData.AttackLevel = .a

  var paiSpecies: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TransactionType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case attack // = 0
    case bonafide // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .attack
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .attack
      case 1: self = .bonafide
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .attack: return 0
      case .bonafide: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum AttackLevel: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case a // = 0
    case b // = 1
    case c // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .a
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .a
      case 1: self = .b
      case 2: self = .c
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .a: return 0
      case .b: return 1
      case .c: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Mobai_PadMetaData.TransactionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mobai_PadMetaData.TransactionType] = [
    .attack,
    .bonafide,
  ]
}

extension Mobai_PadMetaData.AttackLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Mobai_PadMetaData.AttackLevel] = [
    .a,
    .b,
    .c,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mobai"

extension Mobai_BiometricRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BiometricRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "recognition_request"),
    2: .standard(proto: "pad_request"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._recognitionRequest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._padRequest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._recognitionRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._padRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mobai_BiometricRequest, rhs: Mobai_BiometricRequest) -> Bool {
    if lhs._recognitionRequest != rhs._recognitionRequest {return false}
    if lhs._padRequest != rhs._padRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobai_RecognitionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecognitionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reference_image"),
    2: .standard(proto: "reference_meta_data"),
    3: .standard(proto: "probe_image"),
    4: .standard(proto: "probe_meta_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.referenceImage) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._referenceMetaData) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.probeImage) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._probeMetaData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.referenceImage.isEmpty {
      try visitor.visitSingularBytesField(value: self.referenceImage, fieldNumber: 1)
    }
    if let v = self._referenceMetaData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.probeImage.isEmpty {
      try visitor.visitSingularBytesField(value: self.probeImage, fieldNumber: 3)
    }
    if let v = self._probeMetaData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mobai_RecognitionRequest, rhs: Mobai_RecognitionRequest) -> Bool {
    if lhs.referenceImage != rhs.referenceImage {return false}
    if lhs._referenceMetaData != rhs._referenceMetaData {return false}
    if lhs.probeImage != rhs.probeImage {return false}
    if lhs._probeMetaData != rhs._probeMetaData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobai_RecognitionMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RecognitionMetaData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "width"),
    2: .same(proto: "height"),
    3: .same(proto: "orientation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.orientation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 2)
    }
    if self.orientation != .portrait {
      try visitor.visitSingularEnumField(value: self.orientation, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mobai_RecognitionMetaData, rhs: Mobai_RecognitionMetaData) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.orientation != rhs.orientation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobai_RecognitionMetaData.ImageOrientation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PORTRAIT"),
    1: .same(proto: "LANDSCAPE_RIGHT"),
    2: .same(proto: "PORTRAIT_UPSIDE_DOWN"),
    3: .same(proto: "LANDSCAPE_LEFT"),
  ]
}

extension Mobai_PadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PadRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pad_data"),
    2: .standard(proto: "pad_meta_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.padData) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._padMetaData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.padData.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.padData, fieldNumber: 1)
    }
    if let v = self._padMetaData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mobai_PadRequest, rhs: Mobai_PadRequest) -> Bool {
    if lhs.padData != rhs.padData {return false}
    if lhs._padMetaData != rhs._padMetaData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobai_PadMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PadMetaData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .standard(proto: "transaction_type"),
    3: .standard(proto: "item_number"),
    4: .standard(proto: "attack_level"),
    5: .standard(proto: "pai_species"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.transactionType) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.itemNumber) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.attackLevel) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.paiSpecies) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionID.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionID, fieldNumber: 1)
    }
    if self.transactionType != .attack {
      try visitor.visitSingularEnumField(value: self.transactionType, fieldNumber: 2)
    }
    if self.itemNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.itemNumber, fieldNumber: 3)
    }
    if self.attackLevel != .a {
      try visitor.visitSingularEnumField(value: self.attackLevel, fieldNumber: 4)
    }
    if self.paiSpecies != 0 {
      try visitor.visitSingularInt32Field(value: self.paiSpecies, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mobai_PadMetaData, rhs: Mobai_PadMetaData) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.transactionType != rhs.transactionType {return false}
    if lhs.itemNumber != rhs.itemNumber {return false}
    if lhs.attackLevel != rhs.attackLevel {return false}
    if lhs.paiSpecies != rhs.paiSpecies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mobai_PadMetaData.TransactionType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ATTACK"),
    1: .same(proto: "BONAFIDE"),
  ]
}

extension Mobai_PadMetaData.AttackLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "A"),
    1: .same(proto: "B"),
    2: .same(proto: "C"),
  ]
}
